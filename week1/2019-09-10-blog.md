##Solution to yesterday's problem  [Indie Album](https://codeforces.com/problemset/problem/1207/G):

###Problem Analysis 1:
Since it looks like a string problem and it is labeled as hard, maybe it is somehow related to the suffix array! Well, let's add one more constraint that makes the analyzation easier: every songs in the album can append a character and form another song's name at most once. That is to say, the relationship between songs will become several chains. Then, here comes a straight-forward solution: We build the suffix array for each chain and build a segment tree which sort the suffix array respectively. And for each query we do a binary search on the corresponding suffix array then ask how many numbers in that certain range is greater than or equal to the length of the queried string. This can be handled by the segment tree we just built. OK, right now we have a solution to the simplified problem. But how can we remove the constraint we just added? It turns out that the complexity will explode if the songs form several trees instead of only chains since it's not possible to build that much suffix arrays.

###Problem Analysis 2:
The obstacle we just encountered was that the songs form several trees which makes our complexity explodes. How about we manipulate the string on the Trie? Trie fits better in this problem than the suffix array since the suffix array only focuses on a single string and its suffix; however, Trie focuses more on several strings. OK, right now we have a base structure that fits into our problem. Let's recall that what we are going to do in this problem. We want to match strings with strings. Matching strings in a Trie might sound familiar to you... . Isn't this an AC automata?

###Observation:
You might have heard that the complexity of the AC automata is linear to the length of the strings. However, it is also linear to the matches if you want to calculate how many matches occur. If solve the problem normally, your complexity would still explode when the queries are all 'a' and the songs are 'a', 'aa', 'aaa...'. The observation is that there is a property for the songs: their names are generated by the another song. By utilizing this property using DFS and backtrack on the Trie, the complexity which is related to the matching times would be amortized.

###Implementation Process:
Let's build a tree for the songs and stored the queries in it and build an AC automata for the strings in the queries. Then, we build the suffix links or fail tree for the automata. After that, we get the traversing time order for the fail tree. In the end, we traverse the tree for the song and feed the characters into the automata to count the matches between the name of the songs and queries. This counting mechanism can be done by using the time order and the binary indexed tree to help you dfs and backtrack. The essence behind these implementation process is that when given a node in a fail tree, if there is another node such that, it is the ancestor of the given node, then the string represented in the automata by this node (state) is a suffix of the string represented in the automata by the given node (state).

<spoiler summary="Code(C++)">
```
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 4e5+10;
const int ALPHASIZE = 26;

vector<pair<int,int>> songs[MAXN];//(Transition,nextnode)
vector<pair<int,int>> queries[MAXN];//(index in Trie,query number)
vector<int> FailTree[MAXN];
int fail[MAXN];//fail link for automata
int ans[MAXN];
int trans[MAXN][ALPHASIZE];
int time_in[MAXN],time_out[MAXN];//DFS order
int BIT[MAXN];
//The edge of the Trie before build
//the transition for the automata after build
int Trieidx;
int dfs_time;

int insert(string& pattern){
	//insert the string into the Trie
	//return the index of the node in the Trie
	int now=0;
	for(int i=0;i<pattern.size();i++)
		if(trans[now][pattern[i]-'a'])
			now=trans[now][pattern[i]-'a'];
		else
			now=trans[now][pattern[i]-'a']=++Trieidx;
	return now;
}

//build the automata and the fail tree
void build(){
	//build the automata
	int now=0;
	queue<int> q;
	for(int i=0;i<ALPHASIZE;i++)
		if(trans[now][i])
			q.push(trans[now][i]);
	while(!q.empty()){
		now=q.front();q.pop();
		for(int i=0;i<ALPHASIZE;i++){
			if(trans[now][i]){
				fail[trans[now][i]]=trans[fail[now]][i];
				q.push(trans[now][i]);
			}
			else
				trans[now][i]=trans[fail[now]][i];
		}
	}
	//build the fail tree
	for(int i=1;i<=Trieidx;i++)
		FailTree[fail[i]].emplace_back(i);
}

//get the dfs order of the fail tree
void dfs_order(int now){
	time_in[now]=++dfs_time;
	for(int nxt:FailTree[now])
		dfs_order(nxt);
	time_out[now]=dfs_time;
}

//Binary Indexed Tree
void add(int pos,int val){
	for(;pos<=dfs_time;pos+=pos&-pos)
		BIT[pos]+=val;
}

int sum(int pos){
	int ret=0;
	for(;pos;pos-=pos&-pos)
		ret+=BIT[pos];
	return ret;
}

void dfs_solve_query(int Trie_pos,int song_pos){
	//Given a node in a fail tree, if there is another node such that
	//it is the ancestor of the given node, then the string represented
	//in the Trie by this node is a suffix of the string represented in
	//the Trie by the given node.
	add(time_in[Trie_pos],1);
	for(auto it:queries[song_pos])
		ans[it.second]=sum(time_out[it.first])-sum(time_in[it.first]-1);
	for(auto it:songs[song_pos])
		dfs_solve_query(trans[Trie_pos][it.first],it.second);
	add(time_in[Trie_pos],-1);
}

int main(){
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	int n;
	cin>>n;
	//We read the input of the description of the album
	//and build a tree for the songs. Every nodes except the root
	//represents a song. An directed edge in the tree is represented as
	//a pair. The first term is the transistion between nodes and the
	//second term is the index of the next node. Therefore, a path from
	//the root to a node is actually the name of the song. The root's index
	//is 0.
	for(int i=1,type,parent;i<=n;i++){
		char c;
		cin>>type;
		if(type==1){
			parent=0;
			cin>>c;
		}
		else
			cin>>parent>>c;
		songs[parent].emplace_back(make_pair(c-'a',i));
		//shift the letters to 0 ~ 25
	}
	//Build the AC automata or Trie graph for the queries
	int m;
	cin>>m;
	for(int i=1,which;i<=m;i++){
		string pattern;
		cin>>which>>pattern;
		queries[which].emplace_back(make_pair(insert(pattern),i));
	}
	build();//build the automata and fail tree
	dfs_order(0);//get the dfs order of fail tree
	dfs_solve_query(0,0);//solve the queries
	for(int i=1;i<=m;i++)
		cout<<ans[i]<<'\n';
}
```
</spoiler>

###Time Complexity Analysis:
Time Complexity: $O(n|A|+\Sigma|t|log(\Sigma|t|))$.<br>

##Today's POTD (Easy): [Supermarket](https://codeforces.com/problemset/problem/919/A).

###You can discuss in the comments below!
###We are going to have the first official IPL contest in Siebel 1214 at 7 tomorrow!
